# Implementation Guide

## 1) Parsing pipeline (single string)
Input: arbitrary string (often DOM text snippet)

Steps:
1. Normalize
2. Find numeric token
3. Parse numeric token -> `rawAmount`
4. Run false-positive filters
5. Resolve currency evidence (ISO near amount, then unique symbol, then ambiguous symbol)
6. Return `ParseResult`

### 1.1 Normalize
- Trim
- Replace NBSP (U+00A0) + thin space (U+2009) with regular spaces
- Replace apostrophes (', ’) with spaces
- Collapse whitespace to single spaces

No lowercasing; currency markers can be case-sensitive.

### 1.2 Extract numeric token
For v1, support these common patterns:
- `1234`
- `1 234`
- `1,234`
- `1.234`
- `1 234,56`
- `1,234.56`
- `12,50`
- `12.50`

Prefer a single robust regex rather than multiple fragile ones.

### 1.3 Determine decimal separator
Rules:
- If both `,` and `.` exist: the last occurrence is the decimal separator.
- If only one of them exists: treat as decimal only if digits after <= `maxFractionDigits`,
  otherwise treat as thousand separator.
Default `maxFractionDigits`:
- `price`: 2
- `fx`: 4
- `crypto`: 8

### 1.4 False-positive filters
Must reject:
- Phone numbers (10+ digits after removing separators)
- Dates: `YYYY-MM-DD`, `DD/MM/YYYY`, `DD-MM-YYYY`
- Percentages (if `ignorePercentages` true)
- Years if the whole string is `19xx` or `20xx`
- Ranges: `100-200`, `1,299–1,499`
- Sizes: `12x500`

If rejected -> `rawAmount = null`, `status = UNKNOWN`.

### 1.5 Currency resolution
Order of evidence (near the amount, within `maxSymbolDistance` chars):
1) ISO code near amount, and present in ISO 4217 snapshot -> CONFIRMED
2) Unique symbol/token near amount -> CONFIRMED
3) Ambiguous symbol near amount -> AMBIGUOUS + hints
Else -> UNKNOWN

Ambiguous symbols must be derived from `AMBIGUOUS_HINTS` keys to prevent drift.

### 1.6 “Near the amount”
We search in a window around the numeric token index:
- left window: `[amountIndex - maxSymbolDistance, amountIndex)`
- right window: `[amountIndex, amountIndex + maxSymbolDistance)`

For symbol matching:
- Prefer longer symbols first (e.g. `HK$` before `$`).
- Consider normalization that removes spaces inside tokens when comparing (e.g. `US $`).

## 2) parsePriceCandidates (text -> list)
Goal: return multiple candidates with lightweight ranking.

Approach:
- Find all numeric tokens
- For each token, parse with the same core logic
- Compute `score`:
  - base: `rawAmount != null` => +10
  - `CONFIRMED` => +50
  - `AMBIGUOUS` => +20
  - presence of ISO evidence => +30
  - nearby keywords (price/total/subtotal/cost/amount) => +10
  - false-positive pattern => -100
- Return top N by score (default 10), stable sorting for ties.

No heavy ML; keep deterministic.

## 3) Tables and data
- ISO snapshot: `src/data/iso4217.json` generated by script
- Symbols:
  - `UNIQUE_SYMBOLS`: unambiguous tokens (including disambiguated variants like `US$`)
  - `AMBIGUOUS_HINTS`: only tokens mapping to 2+ ISO codes
  - `AMBIGUOUS_SYMBOLS`: `new Set(Object.keys(AMBIGUOUS_HINTS))`

## 4) Compatibility
- Must work in browser and Node (no DOM APIs required)
- Must ship both ESM + CJS bundles and types
- No runtime deps
